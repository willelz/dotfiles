[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_ft = ['typescript', 'typescriptreact', 'typescript.tsx', 'lua', 'sh']
hook_source = '''
lua << EOF
require"fidget".setup{}
local nvim_lsp = require('lspconfig')
local on_attach = function(client, bufnr)
  -- Mappings.
  local opts = { silent = true }
  vim.keymap.set('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  vim.keymap.set('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
  vim.keymap.set('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
  vim.keymap.set('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  vim.keymap.set('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  vim.keymap.set('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  vim.keymap.set('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  vim.keymap.set('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  vim.keymap.set('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  vim.keymap.set('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  vim.keymap.set('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  vim.keymap.set('n', '<space>e', '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  vim.keymap.set('n', '[d', '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  vim.keymap.set('n', ']d', '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
  vim.keymap.set('n', '<space>q', '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)

  -- Set some keybinds conditional on server capabilities
  if client.resolved_capabilities.document_formatting then
    vim.keymap.set("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
  elseif client.resolved_capabilities.document_range_formatting then
    vim.keymap.set("n", "<space>f", "<cmd>lua vim.lsp.buf.range_formatting()<CR>", opts)
  end
end

nvim_lsp.denols.setup { on_attach = on_attach }
nvim_lsp.bashls.setup { on_attach = on_attach }

-- lua
local runtime_path = vim.split(package.path, ';')
table.insert(runtime_path, "lua/?.lua")
table.insert(runtime_path, "lua/?/init.lua")
nvim_lsp.sumneko_lua.setup {
  on_attach = on_attach,
  cmd = { "lua-language-server" },
  filetypes = { "lua" },
  settings = {
    Lua = {
      runtime = {
        -- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)
        version = 'LuaJIT',
        -- Setup your lua path
        path = runtime_path,
      },
      diagnostics = {
        -- Get the language server to recognize the `vim` global
        globals = {'vim'},
      },
      workspace = {
        -- Make the server aware of Neovim runtime files
        library = vim.api.nvim_get_runtime_file("", true),
      },
      -- Do not send telemetry data containing a randomized but unique identifier
      telemetry = {
        enable = false,
      },
    },
  },
}
EOF
'''

[[plugins]]
repo = 'Shougo/ddc.vim'
on_event = ['InsertEnter', 'CursorHold']
hook_source = '''
call ddc#custom#patch_global('autoCompleteEvents', [
    \ 'InsertEnter', 'TextChangedI', 'TextChangedP',
    \ 'CmdlineEnter', 'CmdlineChanged',
    \ ])

call ddc#custom#patch_global('sources', ['around', 'buffer', 'skkeleton'])

call ddc#custom#patch_global('sourceOptions', {
  \ '_' : {
  \   'matchers' : ['matcher_head'],
  \   'sorters' : ['sorter_rank'],
  \ },
  \ 'around' : {'mark' : 'A'},
  \ 'buffer' : {'mark' : 'B', 'requireSameFiletype' : 'v:false'},
  \ 'cmdline' : {'mark' : 'cmdline'},
  \ 'cmdline-history' : {'mark' : 'history', 'sorters': []},
  \ 'necovim' : {'mark' : 'vim'},
  \ 'skkeleton' : {
  \   'mark' : 'skk',
  \   'matchers' : ['skkeleton'],
  \   'sorters' : [],
  \   'minAutoCompleteLength' : 2,
  \ },
  \ 'nvimlsp' : {'mark' : 'lsp', 'forceCompletionPattern': '\.|:|->'},
  \ })

call ddc#custom#patch_global('completionMenu', 'pum.vim')

call ddc#custom#patch_filetype(
  \ ['typescript', 'typescriptreact', 'typescript.tsx'],
  \ 'sources', ['nvim-lsp', 'around', 'buffer', 'skkeleton'])

call ddc#custom#patch_filetype(
  \ 'lua',
  \ 'sources', ['nvim-lsp', 'around', 'buffer', 'skkeleton', 'necovim'])

call ddc#custom#patch_filetype(
  \ ['vim', 'toml'],
  \ 'sources', ['necovim', 'around', 'buffer', 'skkeleton'])

nnoremap : <Cmd>call CommandlinePre()<CR>:

function! CommandlinePre() abort
  " Note: It disables default command line completion!
  cnoremap <expr> <Tab>
  \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
  \ ddc#manual_complete()
  cnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
  cnoremap <C-n>   <Cmd>call pum#map#select_relative(+1)<CR>
  cnoremap <C-p>   <Cmd>call pum#map#select_relative(-1)<CR>
  cnoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
  cnoremap <C-e>   <Cmd>call pum#map#cancel()<CR>

  " Overwrite sources
  let s:prev_buffer_config = ddc#custom#get_buffer()
  call ddc#custom#patch_buffer('sources',
          \ ['cmdline', 'cmdline-history', 'around'])

  call ddc#custom#patch_buffer('keywordPattern', '[0-9a-zA-Z_:#]*')

  autocmd User DDCCmdlineLeave ++once call CommandlinePost()

  " Enable command line completion
  call ddc#enable_cmdline_completion()
  call ddc#enable()
endfunction
function! CommandlinePost() abort
  " Restore sources
  call ddc#custom#set_buffer(s:prev_buffer_config)
  cunmap <Tab>
endfunction

inoremap <silent><expr> <TAB>
      \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
      \ '<TAB>'
inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
inoremap <C-n>   <Cmd>call pum#map#select_relative(+1)<CR>
inoremap <C-p>   <Cmd>call pum#map#select_relative(-1)<CR>
inoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
inoremap <C-e>   <Cmd>call pum#map#cancel()<CR>

call ddc#enable()
'''

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'matsui54/ddc-buffer'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-cmdline'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-cmdline-history'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/neco-vim'
on_source = 'ddc.vim'

[[plugins]]
repo='vim-skk/skkeleton'
on_event = 'InsertEnter'
hook_source='''
function! s:skkeleton_init() abort
  call skkeleton#config({
    \ 'globalJisyo' : $HOME .. '/.skk/SKK-JISYO.L',
    \ 'markerHenkan' : '',
    \ 'markerHenkanSelect' : '',
    \ })
endfunction

imap <C-j> <Plug>(skkeleton-enable)
cmap <C-j> <Plug>(skkeleton-enable)

autocmd User skkeleton-initialize-pre call s:skkeleton_init()
'''

[[plugins]]
repo = 'willelz/teastylua.nvim'
on_ft = "lua"
hook_source = '''
nmap <Space>f <Plug>teastyluaFormat
'''
